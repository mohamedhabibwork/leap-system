---
description: Clean Code and SOLID principles for frontend React/Next.js applications
globs: **/*.ts, **/*.tsx, components/**/*.tsx, app/**/*.tsx, lib/**/*.ts
---

# Clean Code and SOLID Principles - Frontend

## SOLID Principles

### Single Responsibility Principle (SRP)
- Each component should have one reason to change
- Split components by responsibility: presentation, logic, data fetching
- Extract business logic into custom hooks
- Keep components focused on rendering

```typescript
// Bad: Component doing too much
function UserDashboard() {
  const [user, setUser] = useState(null);
  const [courses, setCourses] = useState([]);
  // ... lots of fetch logic, state management, rendering
}

// Good: Separated concerns
function UserDashboard() {
  const user = useCurrentUser();
  const courses = useUserCourses(user?.id);
  
  return <DashboardView user={user} courses={courses} />;
}
```

### Open/Closed Principle (OCP)
- Components open for extension, closed for modification
- Use composition over inheritance
- Leverage props, render props, and children
- Use TypeScript generics for reusable components

```typescript
// Good: Open for extension via props
interface CardProps<T> {
  data: T;
  renderContent: (data: T) => React.ReactNode;
  renderActions?: (data: T) => React.ReactNode;
}

function Card<T>({ data, renderContent, renderActions }: CardProps<T>) {
  return (
    <div className="card">
      <div className="content">{renderContent(data)}</div>
      {renderActions && <div className="actions">{renderActions(data)}</div>}
    </div>
  );
}
```

### Liskov Substitution Principle (LSP)
- Child components must be substitutable for parent components
- Honor component contracts and prop interfaces
- Don't break expected behavior in extended components
- Use proper TypeScript inheritance

```typescript
// Good: Child component honors parent contract
interface ButtonProps {
  onClick: () => void;
  children: React.ReactNode;
}

function Button({ onClick, children }: ButtonProps) {
  return <button onClick={onClick}>{children}</button>;
}

function IconButton({ onClick, children, icon }: ButtonProps & { icon: string }) {
  return (
    <button onClick={onClick}>
      <Icon name={icon} />
      {children}
    </button>
  );
}
```

### Interface Segregation Principle (ISP)
- Don't force components to depend on props they don't use
- Split large prop interfaces into smaller ones
- Use composition for complex components
- Keep interfaces focused

```typescript
// Bad: Component forced to accept unused props
interface FormProps {
  onSubmit: () => void;
  onCancel: () => void;
  onDelete: () => void;
  showDelete: boolean;
}

// Good: Segregated interfaces
interface FormBaseProps {
  onSubmit: () => void;
}

interface CancellableFormProps extends FormBaseProps {
  onCancel: () => void;
}

interface DeletableFormProps extends CancellableFormProps {
  onDelete: () => void;
}
```

### Dependency Inversion Principle (DIP)
- Depend on abstractions, not concrete implementations
- Use dependency injection via props and context
- Create abstract interfaces for services
- Use custom hooks as abstraction layer

```typescript
// Good: Depend on abstraction (interface)
interface DataService<T> {
  fetch: (id: string) => Promise<T>;
  update: (id: string, data: T) => Promise<void>;
}

function DataComponent<T>({ 
  service, 
  id 
}: { 
  service: DataService<T>; 
  id: string; 
}) {
  const { data } = useQuery(['data', id], () => service.fetch(id));
  return <div>{/* render */}</div>;
}
```

## Clean Code Principles

### Naming
- Use descriptive, intention-revealing names
- Use verbs for functions: `handleClick`, `fetchUser`, `validateForm`
- Use nouns for components and variables: `UserCard`, `courseData`
- Use boolean prefixes: `isLoading`, `hasError`, `canEdit`
- Avoid abbreviations and single-letter names (except in loops)

```typescript
// Bad
function Card({ d, onClick }) { }

// Good
function CourseCard({ course, onEnrollClick }) { }
```

### Functions
- Keep functions small and focused (< 20 lines)
- One level of abstraction per function
- Function should do one thing well
- Use descriptive parameter names
- Limit parameters (< 3 ideal, use objects for more)

```typescript
// Bad: Function doing multiple things
function processUser(user) {
  const validated = validateUser(user);
  const saved = saveUser(validated);
  sendEmail(saved.email);
  logActivity(saved.id);
  updateCache(saved);
  return saved;
}

// Good: Single responsibility
function processUser(user: User): Promise<User> {
  return pipe(
    validateUser,
    saveUser,
    notifyUserProcessed,
  )(user);
}
```

### Components
- Keep components under 200 lines
- Extract complex logic into custom hooks
- Use composition over prop drilling
- Prefer named exports
- Co-locate related code

```typescript
// Good: Component structure
// 1. Imports
import { useState } from 'react';
import { Button } from '@/components/ui/button';

// 2. Types
interface CourseCardProps {
  course: Course;
  onEnroll: (id: string) => void;
}

// 3. Component
export function CourseCard({ course, onEnroll }: CourseCardProps) {
  // 3.1 Hooks
  const [expanded, setExpanded] = useState(false);
  
  // 3.2 Event handlers
  const handleEnroll = () => onEnroll(course.id);
  
  // 3.3 Render
  return (
    <div>
      <h3>{course.title}</h3>
      <Button onClick={handleEnroll}>Enroll</Button>
    </div>
  );
}
```

### DRY (Don't Repeat Yourself)
- Extract repeated logic into functions or hooks
- Create reusable components
- Use utility functions for common operations
- Leverage TypeScript generics

```typescript
// Good: Reusable hook
function useApi<T>(endpoint: string) {
  return useQuery<T>({
    queryKey: [endpoint],
    queryFn: () => fetch(endpoint).then(r => r.json()),
  });
}

const { data: courses } = useApi<Course[]>('/api/courses');
const { data: users } = useApi<User[]>('/api/users');
```

### Error Handling
- Handle errors gracefully
- Provide meaningful error messages
- Use Error Boundaries for component errors
- Log errors for debugging
- Show user-friendly error UI

```typescript
// Good: Comprehensive error handling
function CourseList() {
  const { data, error, isError, isLoading } = useCourses();
  
  if (isLoading) return <LoadingSkeleton />;
  if (isError) {
    console.error('Failed to load courses:', error);
    return <ErrorState message="Failed to load courses" onRetry={() => refetch()} />;
  }
  if (!data?.length) return <EmptyState message="No courses found" />;
  
  return <CourseGrid courses={data} />;
}
```

### Comments
- Write self-documenting code
- Comment "why", not "what"
- Use JSDoc for public APIs
- Keep comments up-to-date
- Remove commented-out code

```typescript
// Bad
// Loop through courses
courses.forEach(c => { /* ... */ });

// Good
/**
 * Filters active courses and sorts by enrollment date.
 * Inactive courses are excluded to improve user experience.
 */
function getRecommendedCourses(courses: Course[]): Course[] {
  return courses
    .filter(course => course.status === 'active')
    .sort((a, b) => b.enrolledAt - a.enrolledAt);
}
```

### Code Organization
- Group related code together
- Follow consistent file structure
- Use barrel exports (index.ts)
- Separate concerns (components, hooks, utils, types)
- Keep files focused and small

```
components/
├── course/
│   ├── course-card.tsx
│   ├── course-list.tsx
│   ├── course-filters.tsx
│   ├── index.ts
│   └── types.ts
lib/
├── hooks/
│   ├── use-courses.ts
│   └── use-course-filters.ts
└── utils/
    └── course-helpers.ts
```

### TypeScript Best Practices
- Use strict type checking
- Prefer interfaces for objects
- Use types for unions and utilities
- Avoid `any`, use `unknown` instead
- Leverage type inference
- Use generics for reusable code

### Performance
- Memoize expensive computations with `useMemo`
- Memoize callbacks with `useCallback`
- Use `React.memo` for expensive components
- Implement virtual scrolling for long lists
- Lazy load components with `dynamic` or `React.lazy`
- Optimize images with `next/image`

```typescript
// Good: Memoization
const expensiveValue = useMemo(() => 
  computeExpensiveValue(data),
  [data]
);

const handleClick = useCallback(() => {
  doSomething(id);
}, [id]);
```

### Testing
- Write testable code
- Use dependency injection for easier testing
- Mock external dependencies
- Test behavior, not implementation
- Aim for high coverage of critical paths

### Accessibility
- Use semantic HTML
- Provide ARIA labels
- Ensure keyboard navigation
- Test with screen readers
- Follow WCAG guidelines

## Reusable Component Patterns

### Compound Components
```typescript
// Good: Compound component pattern
export function Card({ children }: { children: React.ReactNode }) {
  return <div className="card">{children}</div>;
}

Card.Header = ({ children }: { children: React.ReactNode }) => (
  <div className="card-header">{children}</div>
);

Card.Body = ({ children }: { children: React.ReactNode }) => (
  <div className="card-body">{children}</div>
);

// Usage
<Card>
  <Card.Header>Title</Card.Header>
  <Card.Body>Content</Card.Body>
</Card>
```

### Render Props
```typescript
// Good: Render props pattern
function DataFetcher<T>({ 
  url, 
  children 
}: { 
  url: string;
  children: (data: T | null, loading: boolean, error: Error | null) => React.ReactNode;
}) {
  const { data, isLoading, error } = useQuery<T>({ queryKey: [url], queryFn: () => fetchData(url) });
  return <>{children(data, isLoading, error)}</>;
}
```

### Higher-Order Components (use sparingly)
```typescript
// Good: HOC for authentication
function withAuth<P extends object>(Component: React.ComponentType<P>) {
  return function AuthComponent(props: P) {
    const { user, isLoading } = useAuth();
    
    if (isLoading) return <LoadingSpinner />;
    if (!user) return <Redirect to="/login" />;
    
    return <Component {...props} user={user} />;
  };
}
```

### Custom Hooks
```typescript
// Good: Reusable custom hook
function useToggle(initialValue = false): [boolean, () => void] {
  const [value, setValue] = useState(initialValue);
  const toggle = useCallback(() => setValue(v => !v), []);
  return [value, toggle];
}
```
