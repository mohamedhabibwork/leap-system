# Frontend Next.js Best Practices

You are an expert in TypeScript, React 19, Next.js 16 App Router, TanStack Query, Zustand, Apollo Client, Socket.io Client, Tailwind CSS 4, and modern frontend architecture.

## Project Context

This is a production-grade Learning Management System (LMS) frontend built with:
- **Framework**: Next.js 16 with App Router
- **React**: React 19 with Server Components
- **Auth**: NextAuth.js v4
- **Data Fetching**: TanStack React Query v5
- **GraphQL**: Apollo Client v4
- **State Management**: Zustand v5
- **Real-time**: Socket.io Client v4
- **Styling**: Tailwind CSS v4
- **UI Components**: Shadcn UI + Radix UI

## Code Style and Structure

### General Principles
- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`).
- Use lowercase with dashes for directories (e.g., `app/user-profile`).
- Favor named exports for components and utilities.
- Avoid default exports except for Next.js page components.

### TypeScript Best Practices
- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use const objects or union types instead.
- Define proper types for props, state, and API responses.
- Use type inference where possible to reduce verbosity.
- Leverage TypeScript's utility types (Pick, Omit, Partial, etc.).
- Create shared types in `lib/types/` for reusability.

## Next.js App Router Guidelines

### File Structure
```
app/
├── (auth)/                   # Auth route group
│   ├── login/
│   │   └── page.tsx
│   ├── register/
│   │   └── page.tsx
│   └── layout.tsx
├── (dashboard)/              # Protected dashboard routes
│   ├── courses/
│   │   ├── [id]/
│   │   │   └── page.tsx
│   │   └── page.tsx
│   ├── profile/
│   │   └── page.tsx
│   └── layout.tsx
├── api/                      # API routes
│   └── auth/
│       └── [...nextauth]/
│           └── route.ts
├── layout.tsx                # Root layout
├── page.tsx                  # Home page
└── error.tsx                 # Error boundary

components/
├── ui/                       # Shadcn UI components
├── features/                 # Feature-specific components
│   ├── courses/
│   ├── auth/
│   └── profile/
└── shared/                   # Shared components

lib/
├── api/                      # API client and hooks
├── auth/                     # Auth utilities
├── graphql/                  # GraphQL queries/mutations
├── stores/                   # Zustand stores
├── types/                    # TypeScript types
└── utils/                    # Utility functions
```

### Server Components (Default)
- Use React Server Components (RSC) by default.
- Fetch data directly in server components.
- Avoid `'use client'` unless necessary for:
  - Event handlers (`onClick`, `onChange`, etc.)
  - React hooks (`useState`, `useEffect`, etc.)
  - Browser APIs (localStorage, window, etc.)
  - Third-party libraries that require client-side code

```typescript
// app/courses/page.tsx (Server Component)
import { getCoursesAction } from '@/lib/actions/courses';
import CourseList from '@/components/features/courses/CourseList';

export default async function CoursesPage() {
  const courses = await getCoursesAction();

  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-6">Courses</h1>
      <CourseList courses={courses} />
    </div>
  );
}
```

### Client Components
- Mark with `'use client'` at the top of the file.
- Keep client components small and focused.
- Extract interactive logic into separate client components.
- Pass server-fetched data as props to client components.

```typescript
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';

interface CourseCardProps {
  course: Course;
}

export default function CourseCard({ course }: CourseCardProps) {
  const [isLiked, setIsLiked] = useState(false);

  return (
    <div className="border rounded-lg p-4">
      <h3>{course.title}</h3>
      <Button onClick={() => setIsLiked(!isLiked)}>
        {isLiked ? 'Unlike' : 'Like'}
      </Button>
    </div>
  );
}
```

### Server Actions
- Use Server Actions for mutations and form submissions.
- Define in separate files in `lib/actions/`.
- Mark with `'use server'` directive.
- Return properly typed results.
- Handle errors and validation.

```typescript
'use server';

import { revalidatePath } from 'next/cache';
import { db } from '@leap-lms/database';

export async function createCourseAction(formData: FormData) {
  try {
    const title = formData.get('title') as string;
    const description = formData.get('description') as string;

    // Validate inputs
    if (!title || title.length < 3) {
      return { error: 'Title must be at least 3 characters' };
    }

    // Create course
    const course = await db.insert(courses).values({
      title,
      description,
    }).returning();

    // Revalidate cache
    revalidatePath('/courses');

    return { success: true, course };
  } catch (error) {
    console.error('Failed to create course:', error);
    return { error: 'Failed to create course' };
  }
}
```

### Layouts
- Use layouts for shared UI and authentication.
- Implement nested layouts for different sections.
- Keep layouts as Server Components when possible.

```typescript
// app/(dashboard)/layout.tsx
import { redirect } from 'next/navigation';
import { getServerSession } from 'next-auth';
import Sidebar from '@/components/shared/Sidebar';
import Header from '@/components/shared/Header';

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await getServerSession();

  if (!session) {
    redirect('/login');
  }

  return (
    <div className="flex h-screen">
      <Sidebar />
      <div className="flex-1 flex flex-col">
        <Header user={session.user} />
        <main className="flex-1 overflow-auto p-6">
          {children}
        </main>
      </div>
    </div>
  );
}
```

### Loading States
- Create `loading.tsx` for automatic loading UI.
- Use Suspense boundaries for granular loading states.
- Implement skeleton loaders for better UX.

```typescript
// app/courses/loading.tsx
import { Skeleton } from '@/components/ui/skeleton';

export default function CoursesLoading() {
  return (
    <div className="container mx-auto py-8">
      <Skeleton className="h-10 w-48 mb-6" />
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        {[...Array(6)].map((_, i) => (
          <Skeleton key={i} className="h-64 w-full" />
        ))}
      </div>
    </div>
  );
}
```

### Error Handling
- Create `error.tsx` for error boundaries.
- Implement proper error UI with retry functionality.
- Use `not-found.tsx` for 404 pages.

```typescript
'use client';

import { useEffect } from 'react';
import { Button } from '@/components/ui/button';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error(error);
  }, [error]);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h2 className="text-2xl font-bold mb-4">Something went wrong!</h2>
      <Button onClick={reset}>Try again</Button>
    </div>
  );
}
```

## Authentication (NextAuth.js)

### Configuration
- Configure NextAuth.js in `app/api/auth/[...nextauth]/route.ts`.
- Use JWT strategy for session management.
- Implement custom callbacks for token and session.

```typescript
// app/api/auth/[...nextauth]/route.ts
import NextAuth from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';

const handler = NextAuth({
  providers: [
    CredentialsProvider({
      name: 'Credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/auth/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(credentials),
        });

        const data = await res.json();

        if (res.ok && data.user) {
          return {
            id: data.user.id,
            email: data.user.email,
            name: data.user.fullName,
            accessToken: data.accessToken,
          };
        }

        return null;
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.accessToken = user.accessToken;
        token.id = user.id;
      }
      return token;
    },
    async session({ session, token }) {
      session.user.id = token.id as number;
      session.accessToken = token.accessToken as string;
      return session;
    },
  },
  pages: {
    signIn: '/login',
    error: '/login',
  },
});

export { handler as GET, handler as POST };
```

### Protected Routes
- Use middleware or layout-based protection.
- Redirect unauthenticated users to login.

```typescript
// middleware.ts
import { withAuth } from 'next-auth/middleware';

export default withAuth({
  callbacks: {
    authorized: ({ token }) => !!token,
  },
});

export const config = {
  matcher: ['/dashboard/:path*', '/courses/:path*', '/profile/:path*'],
};
```

## Data Fetching

### TanStack Query (React Query)
- Use for client-side data fetching and caching.
- Configure QueryClient with proper defaults.
- Create custom hooks for queries and mutations.

```typescript
// lib/providers/QueryProvider.tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { useState } from 'react';

export default function QueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000, // 1 minute
        refetchOnWindowFocus: false,
      },
    },
  }));

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

// lib/api/hooks/useCourses.ts
'use client';

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/lib/api/client';

export function useCourses() {
  return useQuery({
    queryKey: ['courses'],
    queryFn: async () => {
      const { data } = await apiClient.get('/lms/courses');
      return data;
    },
  });
}

export function useCreateCourse() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (courseData: CreateCourseDto) => {
      const { data } = await apiClient.post('/lms/courses', courseData);
      return data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['courses'] });
    },
  });
}
```

### Apollo Client (GraphQL)
- Configure Apollo Client for GraphQL queries.
- Use for complex data requirements and real-time subscriptions.

```typescript
// lib/graphql/client.ts
'use client';

import { ApolloClient, InMemoryCache, createHttpLink } from '@apollo/client';
import { setContext } from '@apollo/client/link/context';

const httpLink = createHttpLink({
  uri: process.env.NEXT_PUBLIC_GRAPHQL_URL,
});

const authLink = setContext((_, { headers }) => {
  const token = localStorage.getItem('accessToken');
  return {
    headers: {
      ...headers,
      authorization: token ? `Bearer ${token}` : '',
    },
  };
});

export const apolloClient = new ApolloClient({
  link: authLink.concat(httpLink),
  cache: new InMemoryCache(),
});

// lib/graphql/queries/courses.ts
import { gql } from '@apollo/client';

export const GET_COURSES = gql`
  query GetCourses($limit: Int) {
    courses(limit: $limit) {
      id
      title
      description
      thumbnail
      instructorId
      createdAt
    }
  }
`;

// Usage in component
'use client';

import { useQuery } from '@apollo/client';
import { GET_COURSES } from '@/lib/graphql/queries/courses';

export default function CourseList() {
  const { data, loading, error } = useQuery(GET_COURSES, {
    variables: { limit: 10 },
  });

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {data.courses.map((course) => (
        <CourseCard key={course.id} course={course} />
      ))}
    </div>
  );
}
```

## State Management (Zustand)

- Use Zustand for global client-side state.
- Keep stores focused and modular.
- Create separate stores for different features.

```typescript
// lib/stores/useAuthStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface AuthState {
  user: User | null;
  accessToken: string | null;
  setAuth: (user: User, accessToken: string) => void;
  clearAuth: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      accessToken: null,
      setAuth: (user, accessToken) => set({ user, accessToken }),
      clearAuth: () => set({ user: null, accessToken: null }),
    }),
    {
      name: 'auth-storage',
    }
  )
);

// Usage in component
'use client';

import { useAuthStore } from '@/lib/stores/useAuthStore';

export default function UserProfile() {
  const { user, clearAuth } = useAuthStore();

  if (!user) return null;

  return (
    <div>
      <h2>{user.fullName}</h2>
      <button onClick={clearAuth}>Logout</button>
    </div>
  );
}
```

## Real-time Communication (Socket.io)

- Create Socket.io context for WebSocket connection.
- Use hooks for subscribing to events.
- Handle connection lifecycle properly.

```typescript
// lib/contexts/SocketContext.tsx
'use client';

import { createContext, useContext, useEffect, useState } from 'react';
import { io, Socket } from 'socket.io-client';

const SocketContext = createContext<Socket | null>(null);

export function SocketProvider({ children }: { children: React.ReactNode }) {
  const [socket, setSocket] = useState<Socket | null>(null);

  useEffect(() => {
    const socketInstance = io(process.env.NEXT_PUBLIC_WS_URL!, {
      auth: {
        token: localStorage.getItem('accessToken'),
      },
    });

    setSocket(socketInstance);

    return () => {
      socketInstance.disconnect();
    };
  }, []);

  return (
    <SocketContext.Provider value={socket}>
      {children}
    </SocketContext.Provider>
  );
}

export const useSocket = () => useContext(SocketContext);

// lib/hooks/useChat.ts
'use client';

import { useEffect, useState } from 'react';
import { useSocket } from '@/lib/contexts/SocketContext';

export function useChat(roomId: string) {
  const socket = useSocket();
  const [messages, setMessages] = useState<Message[]>([]);

  useEffect(() => {
    if (!socket) return;

    socket.emit('joinRoom', roomId);

    socket.on('newMessage', (message: Message) => {
      setMessages((prev) => [...prev, message]);
    });

    return () => {
      socket.emit('leaveRoom', roomId);
      socket.off('newMessage');
    };
  }, [socket, roomId]);

  const sendMessage = (text: string) => {
    if (!socket) return;
    socket.emit('sendMessage', { roomId, text });
  };

  return { messages, sendMessage };
}
```

## Styling (Tailwind CSS)

### Best Practices
- Use Tailwind utility classes for styling.
- Create custom components in `components/ui/` using Shadcn UI.
- Use `cn()` utility for conditional class names.
- Implement responsive design with Tailwind breakpoints.
- Use Tailwind's dark mode support.

```typescript
// lib/utils/cn.ts
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// Usage
import { cn } from '@/lib/utils/cn';

<button
  className={cn(
    'px-4 py-2 rounded-lg font-medium',
    'hover:bg-gray-100 dark:hover:bg-gray-800',
    isActive && 'bg-blue-500 text-white',
    isDisabled && 'opacity-50 cursor-not-allowed'
  )}
>
  Click me
</button>
```

### Responsive Design
```typescript
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
  {/* Responsive grid: 1 column on mobile, 2 on tablet, 3 on desktop */}
</div>

<h1 className="text-2xl md:text-3xl lg:text-4xl font-bold">
  {/* Responsive text sizes */}
</h1>
```

## UI Components (Shadcn UI + Radix UI)

- Use Shadcn UI components from `components/ui/`.
- Customize components using Tailwind classes.
- Leverage Radix UI primitives for accessible components.

```typescript
// components/ui/button.tsx (example Shadcn component)
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils/cn';

const buttonVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-white transition-colors focus-visible:outline-none focus-visible:ring-2',
  {
    variants: {
      variant: {
        default: 'bg-slate-900 text-slate-50 hover:bg-slate-900/90',
        destructive: 'bg-red-500 text-slate-50 hover:bg-red-500/90',
        outline: 'border border-slate-200 bg-white hover:bg-slate-100',
        ghost: 'hover:bg-slate-100',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button';
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = 'Button';

export { Button, buttonVariants };
```

## Forms and Validation

- Use React Hook Form for form handling.
- Implement validation with Zod schemas.
- Create reusable form components.

```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

const loginSchema = z.object({
  email: z.email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

type LoginFormData = z.infer<typeof loginSchema>;

export default function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = async (data: LoginFormData) => {
    // Handle login
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <Input
          {...register('email')}
          type="email"
          placeholder="Email"
          className={errors.email && 'border-red-500'}
        />
        {errors.email && (
          <p className="text-sm text-red-500 mt-1">{errors.email.message}</p>
        )}
      </div>

      <div>
        <Input
          {...register('password')}
          type="password"
          placeholder="Password"
          className={errors.password && 'border-red-500'}
        />
        {errors.password && (
          <p className="text-sm text-red-500 mt-1">{errors.password.message}</p>
        )}
      </div>

      <Button type="submit" disabled={isSubmitting} className="w-full">
        {isSubmitting ? 'Logging in...' : 'Login'}
      </Button>
    </form>
  );
}
```

## Performance Optimization

### Image Optimization
- Use Next.js `Image` component for automatic optimization.
- Specify width and height to prevent layout shift.
- Use `priority` prop for above-the-fold images.

```typescript
import Image from 'next/image';

<Image
  src="/course-thumbnail.jpg"
  alt="Course thumbnail"
  width={400}
  height={300}
  priority
  className="rounded-lg"
/>
```

### Code Splitting
- Use dynamic imports for heavy components.
- Implement lazy loading for below-the-fold content.

```typescript
import dynamic from 'next/dynamic';

const VideoPlayer = dynamic(() => import('@/components/VideoPlayer'), {
  loading: () => <div>Loading player...</div>,
  ssr: false, // Disable SSR for client-only components
});
```

### Memoization
- Use React.memo() for expensive component renders.
- Use useMemo() for expensive calculations.
- Use useCallback() for function references.

```typescript
import { memo, useMemo, useCallback } from 'react';

const ExpensiveComponent = memo(({ data }: { data: Data }) => {
  const processedData = useMemo(() => {
    return data.map((item) => /* expensive operation */);
  }, [data]);

  const handleClick = useCallback(() => {
    // Handle click
  }, []);

  return <div onClick={handleClick}>{/* render */}</div>;
});
```

## SEO and Metadata

- Define metadata in layout and page files.
- Use generateMetadata for dynamic metadata.
- Implement Open Graph and Twitter cards.

```typescript
// app/courses/[id]/page.tsx
import { Metadata } from 'next';

export async function generateMetadata({ params }: {
  params: { id: string };
}): Promise<Metadata> {
  const course = await getCourse(params.id);

  return {
    title: course.title,
    description: course.description,
    openGraph: {
      title: course.title,
      description: course.description,
      images: [course.thumbnail],
    },
  };
}
```

## Environment Variables

- Use `.env.local` for local development.
- Prefix client-side variables with `NEXT_PUBLIC_`.
- Never commit sensitive keys to version control.

```env
# .env.local
NEXT_PUBLIC_API_URL=http://localhost:3000
NEXT_PUBLIC_GRAPHQL_URL=http://localhost:3000/graphql
NEXT_PUBLIC_WS_URL=ws://localhost:3000
NEXTAUTH_SECRET=your-secret-key
NEXTAUTH_URL=http://localhost:3001
```

## Testing

- Write unit tests with Jest and React Testing Library.
- Test user interactions and component behavior.
- Mock API calls and external dependencies.

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import LoginForm from './LoginForm';

describe('LoginForm', () => {
  it('displays error for invalid email', async () => {
    render(<LoginForm />);

    const emailInput = screen.getByPlaceholderText('Email');
    fireEvent.change(emailInput, { target: { value: 'invalid' } });
    fireEvent.blur(emailInput);

    expect(await screen.findByText('Invalid email address')).toBeInTheDocument();
  });
});
```

## Security Best Practices

- Sanitize user inputs to prevent XSS attacks.
- Use HTTPS in production.
- Implement CSRF protection.
- Validate data on both client and server.
- Use Content Security Policy (CSP) headers.
- Keep dependencies updated.
- Never expose sensitive data in client-side code.

## Key Conventions

1. Prioritize React Server Components over Client Components.
2. Use Server Actions for mutations and form submissions.
3. Implement proper authentication and authorization.
4. Leverage Next.js built-in optimizations (Image, Font, etc.).
5. Use TanStack Query for client-side data fetching.
6. Implement proper error and loading states.
7. Follow accessibility best practices (WCAG 2.1).
8. Optimize for Core Web Vitals (LCP, FID, CLS).
9. Write semantic HTML and proper ARIA labels.
10. Keep components small, focused, and reusable.

## Dependencies Reference

- **next**: Next.js framework
- **react**: React library
- **next-auth**: Authentication for Next.js
- **@tanstack/react-query**: Data fetching and caching
- **@apollo/client**: GraphQL client
- **zustand**: State management
- **socket.io-client**: Real-time communication
- **tailwindcss**: Utility-first CSS framework
- **@radix-ui/***: Accessible UI primitives
- **react-hook-form**: Form handling
- **zod**: Schema validation
- **clsx** & **tailwind-merge**: Class name utilities

Refer to existing pages and components for consistent patterns and implementations.
